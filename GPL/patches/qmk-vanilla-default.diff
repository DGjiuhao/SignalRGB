diff --git a/builddefs/common_features.mk b/builddefs/common_features.mk
index 60f1cbd837..93923fff85 100644
--- a/builddefs/common_features.mk
+++ b/builddefs/common_features.mk
@@ -604,6 +604,14 @@ ifeq ($(strip $(CIE1931_CURVE)), yes)
     LED_TABLES := yes
 endif
 
+#ifeq ($(strip $(SIGNALRGB_SUPPORT_ENABLE)), yes)
+    #ifneq ($(strip $(VIA_ENABLE)), yes)
+    RAW_ENABLE := yes
+    SRC += $(QUANTUM_DIR)/signalrgb.c
+    OPT_DEFS += -DSIGNALRGB_SUPPORT_ENABLE
+    #endif
+#endif
+
 ifeq ($(strip $(LED_TABLES)), yes)
     SRC += $(QUANTUM_DIR)/led_tables.c
 endif
diff --git a/quantum/quantum.h b/quantum/quantum.h
index 996e93a12f..6de6cf624f 100644
--- a/quantum/quantum.h
+++ b/quantum/quantum.h
@@ -187,6 +187,12 @@ extern layer_state_t layer_state;
 #    include "joystick.h"
 #endif
 
+#ifdef SIGNALRGB_SUPPORT_ENABLE
+#    ifndef VIA_ENABLE
+#    include "signalrgb.h"
+#    endif
+#endif
+
 #ifdef DIGITIZER_ENABLE
 #    include "digitizer.h"
 #endif
diff --git a/quantum/rgb_matrix/animations/rgb_matrix_effects.inc b/quantum/rgb_matrix/animations/rgb_matrix_effects.inc
index a02238a2d1..00a9731526 100644
--- a/quantum/rgb_matrix/animations/rgb_matrix_effects.inc
+++ b/quantum/rgb_matrix/animations/rgb_matrix_effects.inc
@@ -42,4 +42,5 @@
 #include "starlight_anim.h"
 #include "starlight_dual_sat_anim.h"
 #include "starlight_dual_hue_anim.h"
-#include "riverflow_anim.h"
\ No newline at end of file
+#include "riverflow_anim.h"
+#include "signalrgb_anim.h"
\ No newline at end of file
diff --git a/quantum/via.c b/quantum/via.c
index 643d7aa3c3..6414f8dd54 100644
--- a/quantum/via.c
+++ b/quantum/via.c
@@ -24,6 +24,9 @@
 
 #include "via.h"
 
+#include "qmk_version.h"
+#include "protocol/host.h"
+
 #include "raw_hid.h"
 #include "dynamic_keymap.h"
 #include "eeprom.h"
@@ -188,6 +191,113 @@ bool process_record_via(uint16_t keycode, keyrecord_t *record) {
     return true;
 }
 
+uint8_t packet[32];
+
+ void get_qmk_version(void) //Grab the QMK Version
+{
+        packet[0] = id_signalrgb_qmk_version;
+        packet[1] = QMK_VERSION_BYTE_1;
+        packet[2] = QMK_VERSION_BYTE_2;
+        packet[3] = QMK_VERSION_BYTE_3;
+
+        raw_hid_send(packet, 32);
+}
+
+void get_signalrgb_protocol_version(void) //Grab what version of the SignalRGB protocol a keyboard is running
+{
+        packet[0] = id_signalrgb_protocol_version;
+        packet[1] = PROTOCOL_VERSION_BYTE_1;
+        packet[2] = PROTOCOL_VERSION_BYTE_2;
+        packet[3] = PROTOCOL_VERSION_BYTE_3;
+
+        raw_hid_send(packet, 32);
+}
+
+void get_unique_identifier(void) //Grab the unique identifier for each specific model of keyboard.
+{
+        packet[0] = id_signalrgb_unique_identifier;
+        packet[1] = DEVICE_UNIQUE_IDENTIFIER_BYTE_1;
+        packet[2] = DEVICE_UNIQUE_IDENTIFIER_BYTE_2;
+        packet[3] = DEVICE_UNIQUE_IDENTIFIER_BYTE_3;
+
+        raw_hid_send(packet, 32);
+}
+
+void led_streaming(uint8_t *data) //Stream data from HID Packets to Keyboard.
+{
+    uint8_t index = data[1];
+    uint8_t numberofleds = data[2]; 
+
+    if(numberofleds >= 10)
+    {
+        packet[1] = DEVICE_ERROR_LEDS;
+        raw_hid_send(packet,32);
+        return; 
+    } 
+    
+    for (uint8_t i = 0; i < numberofleds; i++)
+    {
+      uint8_t offset = (i * 3) + 3;
+      uint8_t  r = data[offset];
+      uint8_t  g = data[offset + 1];
+      uint8_t  b = data[offset + 2];
+
+      //if ( ((index + i) == CAPS_LOCK_LED_INDEX && host_keyboard_led_state().caps_lock) || ((index + i) == NUM_LOCK_LED_INDEX && host_keyboard_led_state().num_lock) || ((index + i) == SCROLL_LOCK_LED_INDEX && host_keyboard_led_state().scroll_lock))   {
+      //if ( ((index + i) == CAPS_LOCK_LED_INDEX && host_keyboard_led_state().caps_lock) || ((index + i) == NUM_LOCK_LED_INDEX && host_keyboard_led_state().num_lock))   {
+      //if ( (index + i) == CAPS_MAC_WIN_LED_INDEX && host_keyboard_led_state().caps_lock)   {
+      //if ( (index + i) == CAPS_LOCK_LED_INDEX && host_keyboard_led_state().caps_lock)   {
+      //if ( (index + i) == NUM_LOCK_LED_INDEX && host_keyboard_led_state().num_lock)  {
+      //#if defined(RGBLIGHT_ENABLE)
+      //rgblight_setrgb_at(255, 255, 255, index + i);
+      //#elif defined(RGB_MATRIX_ENABLE)
+      //rgb_matrix_set_color(index + i, 255, 255, 255);
+      //#endif
+
+      //} else {
+
+      #if defined(RGBLIGHT_ENABLE)
+      rgblight_setrgb_at(r, g, b, index + i);
+      #elif defined(RGB_MATRIX_ENABLE)
+      rgb_matrix_set_color(index + i, r, g, b);
+      #endif
+        }
+     }
+//}
+
+void signalrgb_mode_enable(void)
+{
+    #if defined(RGB_MATRIX_ENABLE)
+    rgb_matrix_mode_noeeprom(RGB_MATRIX_SIGNALRGB); //Set RGB Matrix to SignalRGB Compatible Mode
+    #endif
+}
+
+void signalrgb_mode_disable(void)
+{
+    #if defined(RGBLIGHT_ENABLE)
+    rgblight_reload_from_eeprom();
+    #elif defined(RGB_MATRIX_ENABLE)
+    rgb_matrix_reload_from_eeprom(); //Reloading last effect from eeprom
+    #endif
+}
+
+void signalrgb_total_leds(void)//Grab total number of leds that a board has.
+{
+    packet[0] = id_signalrgb_total_leds;
+    #if defined(RGBLIGHT_ENABLE)
+    packet[1] = RGBLED_NUM;
+    #elif defined(RGB_MATRIX_ENABLE)
+    packet[1] = RGB_MATRIX_LED_COUNT;
+    #endif
+    raw_hid_send(packet,32);
+}
+
+void signalrgb_firmware_type(void) //Grab which fork of qmk a board is running.
+{
+    packet[0] = id_signalrgb_firmware_type;
+    packet[1] = FIRMWARE_TYPE_BYTE;
+    raw_hid_send(packet,32);
+}
+
 //
 // via_custom_value_command() has the default handling of custom values for Core modules.
 // If a keyboard is using the default Core modules, it does not need to be overridden,
@@ -287,6 +397,53 @@ void raw_hid_receive(uint8_t *data, uint8_t length) {
     }
 
     switch (*command_id) {
+        case id_signalrgb_qmk_version:
+        {
+            get_qmk_version();
+            break;
+        }
+
+        case id_signalrgb_protocol_version:
+        {
+            get_signalrgb_protocol_version();
+            break;
+        }
+
+        case id_signalrgb_unique_identifier:
+        {
+            get_unique_identifier();
+            break;
+        }
+
+        case id_signalrgb_stream_leds: 
+        {
+            led_streaming(data);
+            break;
+        }
+
+        case id_signalrgb_effect_enable: 
+        {
+            signalrgb_mode_enable();
+            break;
+        }
+
+        case id_signalrgb_effect_disable: 
+        {
+            signalrgb_mode_disable();
+            break;
+        }
+
+        case id_signalrgb_total_leds:
+        {
+            signalrgb_total_leds();
+            break;
+        }
+
+        case id_signalrgb_firmware_type:
+        {
+            signalrgb_firmware_type();
+            break;
+        }
         case id_get_protocol_version: {
             command_data[0] = VIA_PROTOCOL_VERSION >> 8;
             command_data[1] = VIA_PROTOCOL_VERSION & 0xFF;
diff --git a/quantum/via.h b/quantum/via.h
index 01d4c48b37..401aa2d0fc 100644
--- a/quantum/via.h
+++ b/quantum/via.h
@@ -93,9 +93,48 @@ enum via_command_id {
     id_dynamic_keymap_set_buffer            = 0x13,
     id_dynamic_keymap_get_encoder           = 0x14,
     id_dynamic_keymap_set_encoder           = 0x15,
+    id_signalrgb_qmk_version                = 0x21,
+    id_signalrgb_protocol_version           = 0x22,
+    id_signalrgb_unique_identifier          = 0x23,
+    id_signalrgb_stream_leds                = 0x24,
+    id_signalrgb_effect_enable              = 0x25,
+    id_signalrgb_effect_disable             = 0x26,
+    id_signalrgb_total_leds                 = 0x27,
+    id_signalrgb_firmware_type              = 0x28,
     id_unhandled                            = 0xFF,
 };
 
+enum signalrgb_responses {
+    PROTOCOL_VERSION_BYTE_1 = 1,
+    PROTOCOL_VERSION_BYTE_2 = 0,
+    PROTOCOL_VERSION_BYTE_3 = 4,
+    DEVICE_UNIQUE_IDENTIFIER_BYTE_1 = 0,
+    DEVICE_UNIQUE_IDENTIFIER_BYTE_2 = 0,
+    DEVICE_UNIQUE_IDENTIFIER_BYTE_3 = 0,
+    FIRMWARE_TYPE_BYTE = 2, 
+    DEVICE_ERROR_LEDS = 254,
+};
+
+//Changelogs for Firmware Versions------------------------------------
+//V1.0.1 added detection for the total number of LEDs a board has. Plugins need a rewrite to make use of this change. Rewritten plugins will not function with older firmware.
+//V1.0.2 added another detection byte for which fork of SignalRGB firmware device is running. This means we can keep overlap Unique Identifiers between Sonix and Mainline.
+//V1.0.3 unifies the command IDs between Mainline, Sonix, and VIA. All commands have a 0x20 offset now.
+//V1.0.4 improves detection handling, and has a complete rewrite of the plugins. Also merges Mainline and VIA branches. VIA Branch is deprecated.
+
+/*
+DEVICE, DEVICE_UNIQUE_IDENTIFIER_BYTE_1,DEVICE_UNIQUE_IDENTIFIER_BYTE_2,DEVICE_UNIQUE_IDENTIFIER_BYTE_3
+gmmk/pro/rev1/ansi:default                  0 0 5
+gmmk/pro/rev2/ansi:default                  0 0 5
+gmmk/pro/rev1/iso:default                   0 0 6
+gmmk/pro/rev2/iso:default                   0 0 6
+gmmk/gmmk2/p65/ansi:default                 0 0 7
+gmmk/gmmk2/p65/iso:default                  0 0 8
+gmmk/gmmk2/p96/ansi:default                 0 0 9
+gmmk/gmmk2/p96/iso:default                  0 0 10
+redragon/k556:via                       0 1 3
+redragon/k580:via                       0 1 4
+*/
+
 enum via_keyboard_value_id {
     id_uptime              = 0x01,
     id_layout_options      = 0x02,
@@ -160,6 +199,16 @@ uint32_t via_get_layout_options(void);
 void     via_set_layout_options(uint32_t value);
 void     via_set_layout_options_kb(uint32_t value);
 
+//Used to handle SignalRGB Compatibility
+void get_qmk_version(void);
+void get_signalrgb_protocol_version(void);
+void get_unique_identifier(void);
+void led_streaming(uint8_t *data);
+void signalrgb_mode_enable(void);
+void signalrgb_mode_disable(void);
+void signalrgb_total_leds(void);
+void signalrgb_firmware_type(void);
+
 // Used by VIA to tell a device to flash LEDs (or do something else) when that
 // device becomes the active device being configured, on startup or switching
 // between devices.
